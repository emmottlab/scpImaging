### Functions for analysing cellenONE image metadata produced by cellpose or CellProfiler

# Currently this includes
# 1. countCells() - status: functional - need to tidy

##############################################################################################################

#' Count Unique Masks in Cellpose PNG Files using magick
#'
#' @description
#' Processes PNG segmentation masks (typically generated by Cellpose) using the
#' `magick` package to count the number of unique positive integer values.
#' These values correspond to individual segmented objects (e.g., cells),
#' while background pixels (value 0) are ignored.
#' The function can handle input specified as a directory containing masks, an
#' explicit list of mask file paths, or a directory and a filename suffix.
#'
#' @details
#' This function reads PNG files using `magick::image_read`. It then uses
#' `magick::image_data` to extract the raw pixel data for the grayscale
#' channel.
#'
#' Because `magick::image_info` may not reliably return the bit depth for all
#' PNG files, this function uses the `expected_bit_depth` argument to interpret
#' the raw pixel data (bytes):
#' - If `expected_bit_depth` is 8, raw bytes directly represent integer values (0-255).
#' - If `expected_bit_depth` is 16, pairs of raw bytes are combined to reconstruct the
#'   16-bit integer values (0-65535), assuming big-endian byte order.
#'
#' The function assumes that the input PNGs are grayscale integer images where
#' different masks are represented by unique positive integers and the
#' background is 0. If non-grayscale images are encountered, a warning is
#' issued, and the function attempts to process the grayscale information.
#'
#' The function includes error handling: if a file cannot be read or processed
#' (e.g., corrupted file, non-PNG format, unsupported expected bit depth),
#' a warning is issued, and `NA` is returned for that file's count.
#'
#' Provide *either* `path` (optionally with `suffix`) *or* `filelist`, but not both.
#'
#' @param path A character string specifying the path to the directory
#'   containing the PNG mask files. Mutually exclusive with `filelist`.
#'   Defaults to `NULL`.
#' @param filelist A character vector of full file paths to the PNG mask files.
#'   Mutually exclusive with `path`. Defaults to `NULL`.
#' @param suffix A character string specifying the filename suffix (pattern)
#'   to match when `path` is provided. The pattern is matched at the end of
#'   the filename. Defaults to `".png"`. Ignored if `filelist` is provided.
#' @param expected_bit_depth A numeric value indicating the expected bit depth
#'   of the original PNG mask files (typically 8 or 16). This is used to
#'   interpret the raw pixel data correctly. Defaults to 8.
#'
#' @return A dataframe with two columns:
#'   \item{FileName}{Character, the base name of the processed PNG file.}
#'   \item{CP_CellCount}{Integer, the number of unique positive integer mask
#'   values found in the image. Contains `NA` if the file could not be
#'   processed.}
#'
#' @importFrom magick image_read image_data image_info image_write
#' @export
#'
#' @examples
#' \dontrun{
#' # Example Setup: Create dummy PNG mask files using the 'magick' package
#' temp_dir <- tempdir()
#' # Mask 1: 2 objects (IDs 1, 2)
#' mask1_data <- matrix(c(0, 0, 1, 1, 0, 2, 2, 0, 0), nrow = 3, byrow = TRUE)
#' # Mask 2: 4 objects (IDs 1, 2, 3, 4)
#' mask2_data <- matrix(c(1, 1, 1, 0, 0, 0, 2, 3, 4), nrow = 3, byrow = TRUE)
#' # Mask 3: 3 objects (IDs 10, 20, 300) - requires 16-bit
#' mask3_data_16bit <- matrix(c(0, 10, 20, 300), nrow = 2, byrow = TRUE)
#'
#' # Create magick images from matrices (scale to 0-1 for image_read)
#' # Save as 16-bit PNGs to handle mask3
#' max_val_16bit <- 65535
#' img1_magick <- magick::image_read(mask1_data / max_val_16bit)
#' img2_magick <- magick::image_read(mask2_data / max_val_16bit)
#' img3_magick <- magick::image_read(mask3_data_16bit / max_val_16bit)
#'
#' # Set depth to 16-bit before writing
#' img1_magick <- magick::image_depth(img1_magick, 16)
#' img2_magick <- magick::image_depth(img2_magick, 16)
#' img3_magick <- magick::image_depth(img3_magick, 16)
#'
#' # Write PNGs using magick
#' magick::image_write(img1_magick,
#'                     path = file.path(temp_dir, "imageA_masks.png"),
#'                     format = "png")
#' magick::image_write(img2_magick,
#'                     path = file.path(temp_dir, "imageB_masks.png"),
#'                     format = "png")
#' magick::image_write(img3_magick,
#'                     path = file.path(temp_dir, "imageC_16bit_masks.png"),
#'                     format = "png")
#'
#' # Create a non-png file to test error handling
#' writeLines("not a png", file.path(temp_dir, "not_a_png.txt"))
#'
#' # --- Usage Examples ---
#'
#' # 1. Using path and default suffix (".png") and default depth (16)
#' counts_path_default <- count_cp_masks_magick(path = temp_dir)
#' print(counts_path_default)
#' # Expected output: Counts for A, B, C (2, 4, 3 respectively)
#'
#' # 2. Using path and specific suffix, explicitly setting 16-bit depth
#' counts_path_suffix <- count_cp_masks_magick(path = temp_dir,
#'                                             suffix = "_masks.png",
#'                                             expected_bit_depth = 16)
#' print(counts_path_suffix)
#' # Expected output: Counts for A, B, C (2, 4, 3 respectively)
#'
#' # 3. Using filelist (including non-png and non-existent files to show NA)
#' file_paths <- c(
#'   file.path(temp_dir, "imageA_masks.png"),
#'   file.path(temp_dir, "imageB_masks.png"),
#'   file.path(temp_dir, "imageC_16bit_masks.png"),
#'   file.path(temp_dir, "non_existent_file.png"), # Test non-existent file
#'   file.path(temp_dir, "not_a_png.txt")          # Test invalid file
#' )
#' counts_filelist <- count_cp_masks_magick(filelist = file_paths,
#'                                          expected_bit_depth = 16)
#' print(counts_filelist)
#' # Expected output: Counts for A, B, C, and NA for the last two with warnings.
#'
#' # 4. Example assuming masks were 8-bit (will misinterpret C)
#' #    (Need to recreate test files as 8-bit for this to be accurate)
#' # counts_8bit <- count_cp_masks_magick(path = temp_dir,
#' #                                      suffix = "_masks.png",
#' #                                      expected_bit_depth = 8)
#' # print(counts_8bit)
#'
#' # Clean up temporary files
#' unlink(temp_dir, recursive = TRUE)
#' }
#'
count_cp_masks_magick <- function(path = NULL, filelist = NULL, suffix = ".png", expected_bit_depth = 8) {

  # --- Input Validation ---
  stopifnot("Provide either 'path' or 'filelist', but not both." = (!is.null(path) +!is.null(filelist) == 1),
            "If provided, 'path' must be a single character string." = (is.null(path) || (is.character(path) && length(path) == 1)),
            "If provided, 'filelist' must be a character vector." = (is.null(filelist) || is.character(filelist)),
            "'suffix' must be a single character string." = (is.character(suffix) && length(suffix) == 1),
            "'expected_bit_depth' must be a single numeric value." = (is.numeric(expected_bit_depth) && length(expected_bit_depth) == 1),
            "'expected_bit_depth' must be 8 or 16." = (expected_bit_depth %in% c(8, 16)))

  if (!is.null(path)) {
    stopifnot("Provided 'path' does not exist or is not a directory." = dir.exists(path))
  }

  # --- Determine Files to Process ---
  if (!is.null(path)) {
    # Ensure suffix pattern matches end of string, case-insensitive
    pattern_safe <- paste0(gsub("([.^$*+?()[{\\|])", "\\\\\\1", suffix), "$")
    files_to_process <- list.files(path = path, pattern = pattern_safe, full.names = TRUE, ignore.case = TRUE)
    if (length(files_to_process) == 0) {
      warning("No files found in '", path, "' matching suffix '", suffix, "'")
      return(data.frame(FileName = character(0), CP_CellCount = integer(0)))
    }
  } else {
    files_to_process <- filelist
  }

  # --- Process Files ---
  results_list <- vector("list", length(files_to_process))
  names(results_list) <- basename(files_to_process)

  for (i in seq_along(files_to_process)) {
    file_path <- files_to_process[i]
    file_base_name <- basename(file_path)

    count <- tryCatch({
      # Check file existence before attempting to read with magick
      if (!file.exists(file_path)) {
        stop("File not found.")
      }

      # Read image using magick
      img_magick <- magick::image_read(file_path)

      # Get image info (only first frame if multiple) - mainly for width/height now
      info <- magick::image_info(img_magick)[1, ]
      width <- info$width
      height <- info$height
      colorspace <- info$colorspace

      # Check colorspace - warn if not explicitly Gray or Grayscale, but proceed
      if (!is.na(colorspace) &&!colorspace %in% c("Gray", "Grayscale")) {
        warning(paste("Image", file_base_name, "colorspace is", colorspace, "(expected Gray/Grayscale). Proceeding by extracting grayscale channel data."), call. = FALSE)
      }

      # Extract raw grayscale pixel data (returns raw array: width x height x channels)
      img_raw <- magick::image_data(img_magick, channels = 'gray')

      if (is.null(img_raw) || length(img_raw) == 0) {
        stop("Extracted raw pixel data is empty or NULL.")
      }

      # Convert raw data to integer vector based on EXPECTED depth
      img_int_vec <- NULL # Initialize
      if (expected_bit_depth == 8) {
        # Raw bytes directly represent 8-bit integers
        # Check length consistency
        expected_len_8bit <- as.numeric(width) * as.numeric(height) # Ensure numeric calculation
        if (length(img_raw)!= expected_len_8bit) {
          stop(paste("Raw data length", length(img_raw), "mismatch for 8-bit image. Expected", expected_len_8bit))
        }
        img_int_vec <- as.integer(img_raw)
      } else if (expected_bit_depth == 16) {
        # Raw bytes need to be combined for 16-bit integers
        # Check length consistency (2 bytes per pixel)
        expected_len_16bit_raw <- as.numeric(width) * as.numeric(height) * 2 # Ensure numeric calculation
        if (length(img_raw)!= expected_len_16bit_raw) {
          stop(paste("Raw data length", length(img_raw), "mismatch for 16-bit image. Expected", expected_len_16bit_raw))
        }
        # Ensure raw data is treated as a single byte stream
        raw_bytes <- as.vector(img_raw)
        # Read 16-bit unsigned integers, assuming big-endian (network byte order common in PNG)
        # Use readBin for efficient conversion
        expected_pixels_16bit <- as.numeric(width) * as.numeric(height) # Ensure numeric calculation
        img_int_vec <- readBin(raw_bytes, what = "integer", size = 2, n = expected_pixels_16bit, signed = FALSE, endian = "big")
      } else {
        # This case should be caught by initial stopifnot, but included for safety
        stop(paste("Unsupported expected_bit_depth:", expected_bit_depth, ". Only 8 or 16 are supported."))
      }

      if (is.null(img_int_vec) || length(img_int_vec) == 0) {
        stop("Failed to convert raw data to integer vector.")
      }

      # Check if the number of pixels matches expected dimensions
      expected_total_pixels <- as.numeric(width) * as.numeric(height) # Ensure numeric calculation
      if (length(img_int_vec)!= expected_total_pixels) {
        stop(paste("Integer pixel vector length mismatch. Expected", expected_total_pixels, "pixels, but got", length(img_int_vec)))
      }

      # Get unique non-zero pixel values (mask IDs)
      unique_values <- unique(img_int_vec)
      if (length(unique_values) == 0 && length(img_int_vec) > 0) {
        # This case might happen if all pixels are the same (e.g., all 0)
        # but unique() should still return that one value. Check if img_int_vec was valid.
        warning(paste("unique() returned empty set for", file_base_name, "despite non-empty input vector. Check pixel values."), call. = FALSE)
        mask_ids <- integer(0) # Empty set of mask IDs
      } else {
        mask_ids <- setdiff(unique_values, 0) # Exclude background (0)
      }

      # Return the count of unique positive mask IDs
      length(mask_ids)

    }, error = function(e) {
      # Make the warning message more informative by including the specific error
      warning(paste("Failed to process file:", file_base_name, "- Error:", conditionMessage(e)), call. = FALSE)
      return(NA_integer_) # Return NA for the count on error
    }) # end tryCatch

    results_list[[i]] <- count
  } # end for loop

  # --- Format Output ---
  output_df <- data.frame(
    FileName = names(results_list),
    CP_CellCount = unlist(results_list),
    row.names = NULL # Ensure row names are default integers
  )

  return(output_df)
}

##############################################################################################################

# Function: add number of cell metadata columns based on  cellpose mask files to QFeatures object

# Function: integrate CellProfiler output into annotation dataframe
# Function: integrate CellProfiler output tables into QFeatures object

