% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/imageAnalysis.R
\name{addCellProfilerAttributes}
\alias{addCellProfilerAttributes}
\title{'addCellProfilerAttributes()': Add Attributes from a Second Data Frame Based on Keys}
\usage{
addCellProfilerAttributes(
  df1,
  df2,
  key1_col = "Cropped_Path",
  key2_col = "FileName_Image",
  multiplet_handling = c("voidmultiplets", "takemaxarea"),
  area_col = "AreaShape_Area"
)
}
\arguments{
\item{df1}{The primary data frame (data.frame or tibble). All rows from this
data frame will be kept.}

\item{df2}{The secondary data frame (data.frame or tibble) containing the
attributes to add.}

\item{key1_col}{The name of the key column in \code{df1} (character string).
Defaults to \code{"Cropped_Path"}.}

\item{key2_col}{The name of the key column in \code{df2} (character string).
Defaults to \code{"FileName_Image"}.}

\item{multiplet_handling}{Method to handle multiple rows for the same key in \code{df2}.
Must be one of \code{"voidmultiplets"} or \code{"takemaxarea"} (character string).
Defaults to \code{"voidmultiplets"}.}

\item{area_col}{The name of the column in \code{df2} containing the area values,
required only if \code{multiplet_handling = "takemaxarea"} (character string).
Defaults to \code{"AreaShape_Area"}.}
}
\value{
A data frame containing all rows and columns from \code{df1}, augmented
with columns from \code{df2} based on the matched keys and the specified
\code{multiplet_handling} strategy. Columns added from \code{df2} will exclude the
key column (\code{key2_col}).
}
\description{
Merges attributes (columns) from a second data frame (\code{df2}) into a primary
data frame (\code{df1}) based on specified key columns. This function performs a
left join, keeping all rows from \code{df1}. It provides options for handling
cases where keys in \code{df2} represent multiple measurements (multiplets).
}
\details{
The function uses key columns \code{key1_col} from \code{df1} and \code{key2_col} from \code{df2}
to match rows. All rows from \code{df1} are preserved.

Handling of multiple rows for the same key (multiplets) in \code{df2}:
\itemize{
\item \code{voidmultiplets} (default): If a key in \code{key2_col} appears in multiple
rows of \code{df2}, the corresponding rows in the merged output will have \code{NA}
values for all columns originating from \code{df2}.
\item \code{takemaxarea}: If a key in \code{key2_col} appears in multiple rows of \code{df2},
only the data from the single \code{df2} row having the maximum value in the
\code{area_col} column will be added to \code{df1}, i.e. the largest cell. If the values are
identical, will take the first encountered row among those with the maximum area.
}
}
\examples{
# --- Sample Data ---
df1 <- data.frame(
  ID = 1:5,
  Cropped_Path = c("path/A", "path/B", "path/C", "path/D", "path/E"),
  OtherData1 = rnorm(5)
)

df2 <- data.frame(
  FileName_Image = c("path/A", "path/B", "path/B", "path/C", "path/C", "path/F"),
  AttributeX = letters[1:6],
  AreaShape_Area = c(100, 150, 120, 200, 250, 50),
  AttributeY = LETTERS[1:6]
)

# --- Usage Examples ---

# Example 1: Default behavior ('voidmultiplets')
merged_void <- addCellProfilerAttributes(df1, df2)
print(merged_void)

# Example 2: Using 'takemaxarea' to resolve multiplets ## Changed value in comment
# For "path/B", the row with AreaShape_Area = 150 is kept.
# For "path/C", the row with AreaShape_Area = 250 is kept.
merged_take_max <- addCellProfilerAttributes(df1, df2,
                                        multiplet_handling = "takemaxarea") ## Changed value here
print(merged_take_max)


}
